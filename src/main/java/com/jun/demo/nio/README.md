# NIO
## 一、介绍
XXXBuffer：通过allocate（）获取缓冲区
## 二、缓冲区存取数据的核心方法
- put()：存入数据到缓冲区
- get()：获取缓冲区中的数据
## 三、缓冲区中的四个核心属性：
- capacity：容量，表示缓冲区的最大存储容量，一旦生命不能改变
- limit：界限，表示缓冲区中可以操作数据的大小，（limit后的数据是不能进行读写）
- position：位置，表示缓冲区中正在操作数据的位置
- mark：标记，表示记录当前position的位置，可以通过 reset() 恢复到 mark 的位置

    0 <= mark <= position <= limit <= capacity
## 四、直接缓冲区 与 非直接缓冲区
- 直接缓冲区：通过allocate() 方法 分配缓冲区，将缓冲区建立在ＪＶＭ的内存中
- 非直接缓冲区：通过allocateDirect() 方法分配直接缓冲区，将缓冲区建立在物理内存中，可以提高效率
直接 与 非直接的区别
字节缓冲区要么直接要么是非直接的。
- 如果为直接字节缓冲区，则 JVM 会尽最大的努力直接在此缓冲区上执行本机I/O操作
即，在每次调用基础操作系统的一个本机I/O操作之前（或之后）JVM 都会尽量避免将缓冲区的内容复制到中间缓冲区中（或从中间缓冲区中复制内容）
- 直接字节缓冲区可以通过调用此类的allocateDirect() 工厂方法来床，此方法==返回的缓冲区进行分配可取消分配所需成本通常高于非直接缓冲区==
直接缓冲区的内容可以驻留在常规的垃圾回收堆之外。因此，它们堆应用程序的内存需求量造成的影响可能不明显。
所以，建议直接将缓存区主要分配给那些易受基础系统的本机I/O操作影响的大型、持久缓冲区。一般情况下，最好仅在直接缓冲区能在程序性能方面带来明显好处时分配它们
- 直接字节缓冲区还可以通过FileChannel的map方法将文件区域直接映射到内存中来创建，该方法返回MappedByteBuffer。Java 平台的实现有助于通过JNI从本机代码创建直接字节缓冲区。
如果以上这些缓冲区中的某个缓冲区实例是不可访问的内存区域，则试图访问区域不会更改该缓冲区的内容，并且将会在访问期间或稍后的某个时间导致抛出不确定的异常
- 字节缓冲区是否是直接缓冲区可以通过调用 isDirect()方法来确定。提供此方法是为了能在性能关键型代码中执行显式缓冲区管理

## 阻塞与非阻塞 （使用NIO完成网络通信的三个核心）
- 通道（Chanel）：负责连接
	java.nio.channels.Channel 接口：
		|-- SelectableChannel
		|-- SocketChannel
		|-- ServerSocketChannel
		|-- DatagramChannel
		
		|-- Pipe.SinkChannel
		|-- Pipe.SourceChannel
- 缓冲区（Buffer）：负责数据存取
- 连接器（Selector）：是SelectableChannel 的多路复制器，用于监控SelectableChannel 的 IO状况


